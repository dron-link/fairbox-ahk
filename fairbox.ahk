#Requires AutoHotkey v1.1.37
#Warn All, OutputDebug
#SingleInstance force
#NoEnv
#include <CvJoyInterface>

allowTrimming := true ; trim to the coordinate circle

#include %A_ScriptDir%
#include, engineConstants.ahk ; needed for everything else
#include, hkIniAutogenerator.ahk
#include, testingTools.ahk
#include, targetObjStructure.ahk ; needed for creating baseTarget class
target := new baseTarget
#include, targetCoordinateValues.ahk ; you can customize the coordinates here
#include, targetFormatting.ahk
SetBatchLines, -1
/*
   this file is agirardeaudale B0XX-autohotkey  https://github.com/agirardeau/b0xx-ahk
   i, dron-link, am weaving new features into it, creating 'fairbox'

 DISCLAIMER
 I AM NOT A PROGRAMMER BY TRADE. i believe that the community would appreciate if you, a programmer,
 took matters in your hands and made a more powerful, stable, and readable version of this program. 
 Other than to use it after the lack of alternatives, I made this with the 
 hope that this script contains any useful ideas for you.

 contact info:
 Discord
    aiiiiiiiiiiu     ; over at B0XX server
 GitHub
    https://github.com/dron-link

 sdi and pivot nerfs adapted from CarVac 's work  https://github.com/CarVac/HayBox
 more info extracted from B0XX documentation  https://b0xx.com/pages/resources
 and B0XX: The Movie  https://www.youtube.com/watch?v=uTYSgyca8cI
 and the Melee Controller Ruleset Proposal 2024 (outdated?)
 https://docs.google.com/document/d/1abMqoatAGh_ZhQD1qJaQx6YqFAppCjU5KyF3mgvDQVw/
 and Altimor's Stickmap https://marp-e3fcf.web.app/

 When I messaged CarVac and Practical_TAS, they were kind enough to answer a couple of my questions.

  ---------------------

 this project is proof of concept of how can we implement a variety of analog stick nerfs in Autohotkey. 

 everything is subject to modification and may not be present in the finalized version.
 +++ i'm considering helping to make a faithful b0xx v4.1-like for keyboards in the future.

 rough change list and to-do
 - implemented neutral SOCD, did away with the old SOCD handling for now
 - implemented empty pivot nerfing. it will need lots of timing accuracy testing and trigger testing, but as of now it does the job
 - reimplemented reverse neutral-B lockout nerf
 - implement crouch to uptilt nerf
 - allow for c-stick button leftstick angle modifier binding changes (or c-stick-angle-bindings for short) 
    by editing a certain autogenerated file
 - implemented coordinate circle clamping
 - implemented 1.0 cardinal fuzzing (y fuzzing). UCF and v1.03 fixes are compatible with this nerf

 - TODO explore creating a function that will handle all timing lockout nerfs the same way, kind of
   detectAndNerf(pivotDirection, pivotTimestamp, dashZone, dashZoneTimestamp)
 - TODO explore writing a function nerfConflictManager () to deal with pivot vs. sdi, and uncrouch vs. sdi. prioritize player input
 - TODO implement SDI nerfs
 - TODO use setTimer to lift nerfs without waiting for player input
    ¬ call updateAnalogStick and possibly lift pivot nerfs after 4 frames, 5 frames and 8 frames
    ¬ use setTimer to lift a 2fjump nerf 2 frames after it was forced (idea origin: CarVac)
 - TODO implement coordinate target inconditional bans
 - TODO make most meleeLimits functions external and bring them here with #Include %A_ScriptDir, #Include *.ahk
 - TODO write tests
 - TODO make some in-game debug display by taking control of the c-stick and d-pad (idea origin: CarVac)
 - TODO make some global variables into static locals
 - TODO make debug flags and debugACertainProcess? outputDebug, % expression


setTimer firing rate is apparently 15.6ms, don't expect much precision from it 
(at least it's shorter than a game cube input polling interval), but I expect that most nerf lifts will be one frame late sometimes.
Maybe we can improve the script by increasing the polling frequency? solution using WinMM


 /-------------------------------------------------------------------/


  APPROACH
  
  We add an intermediate step in the updateAnalogStick() function.
  We take the coordinates (x, y) that are solely determined by the current keypresses 
    and we limit what they could do ingame by sending to the game the output of limitOutputs(x, y) instead.

  -History approach: (adapted from CarVac). 
  We store the information of outputs passed to the game so we can refer to them in later limitOutputs() calls.

  - Handling simultaneous leftstick button presses:
    We grant a grace period of 3 milliseconds intervals before writing the corresponding input entry in history.
    People virtually never press two buttons at the exact same time even when they intend to, 
  and either Autohotkey, the OS or the keyboard can be arbitrary with how they process "simultaneous" inputs
  and the time gap between them.
    With our input processing method, any input/output undone before this timelimit settles, 
  won't count when reading the history to detect techniques.
    With this, we mainly want to factor out inconsistencies between different keyboard brands.
    We deduced that this makes the detection of techniques more accurate and consistent accross gaming setups.

  - Pivot detection. (empty pivots) ( Adapted from CarVac 's work )
    The detector trips if you input a dash, 
  and if, before entering run state, you terminate your dash by inputting another dash in the opposite direction for about 1 frame.
    Once we detect an empty pivot, we make certain actions unavailable for a number of frames. 
    (What we do is change a prohibited action into another action)

  - Uncrouch detection ( Adapted from CarVac 's work)
    This detector trips when you exit the leftstick vertical range that allows the player to hold crouch 
  (independently of if the character was actually in the crouch state, knees bending and everything)
    We rule out inputting an up-tilt until a certain number of frames pass.

  - Horizontal 1.0 fuzzing
    The Game cube controller can be inconsistent in, or uncapable of, reaching horizontal 1.0 or -1.0, getting stuck at +/-0.9875 . 
    We emulate some of that inconsistency by sometimes outputting +/- 0,9875 instead of +/- 1.0.
    Still, Universal Controller Fix v0.84 (and alternatively SSBM1.03) 
  gets rid of these problems for Game cube controllers "and" for this script.
  
*/

ANALOG_HISTORY_LENGTH := 5 ; MINIMUM 1
SDI_HISTORY_LENGTH := 5 ; MINIMUM 5
DASH_HISTORY_LENGTH := 3 ; MINIMUM 3

/* 
  ctrl-f this: Manual_Nerf_Testing
  SET TO 0 TO MAKE THE SCRIPT BEHAVE NORMALLY
 */
nerfTestMode :=0

hotkeys := [ "Analog Up"             ; 1
           , "Analog Down"           ; 2
           , "Analog Left"           ; 3
           , "Analog Right"          ; 4
           , "ModX"                  ; 5
           , "ModY"                  ; 6
           , "A"                     ; 7
           , "B"                     ; 8
           , "L"                     ; 9
           , "R"                     ; 10
           , "X"                     ; 11
           , "Y"                     ; 12
           , "Z"                     ; 13
           , "C-stick Up"            ; 14
           , "C-stick Down"          ; 15
           , "C-stick Left"          ; 16
           , "C-stick Right"         ; 17
           , "Light Shield"          ; 18
           , "Mid Shield"            ; 19
           , "Start"                 ; 20
           , "D-pad Up"              ; 21
           , "D-pad Down"            ; 22
           , "D-pad Left"            ; 23
           , "D-pad Right"           ; 24
           , "Debug"]                ; 25

; this method reads c-stick-angle-bindings.ini and assigns coordinates appropiately
target.bindAnglesToCStick()

Menu, Tray, Click, 1
Menu, Tray, Add, Edit Controls, ShowGui
Menu, Tray, Default, Edit Controls

for index, element in hotkeys{
 Gui, Add, Text, xm vLB%index%, %element% Hotkey:
 IniRead, savedHK%index%, hotkeys.ini, Hotkeys, %index%, %A_Space%
 If savedHK%index%                                       ;Check for saved hotkeys in INI file.
  Hotkey,% savedHK%index%, Label%index%                 ;Activate saved hotkeys if found.
  Hotkey,% savedHK%index% . " UP", Label%index%_UP                 ;Activate saved hotkeys if found.
  ;TrayTip, B0XX, Label%index%_UP, 3, 0
  ;TrayTip, B0XX, % savedHK%A_Index%, 3, 0
  ;TrayTip, B0XX, % savedHK%index% . " UP", 3, 0
 checked := false
 if(!InStr(savedHK%index%, "~", false)){
  checked := true
 }
 StringReplace, noMods, savedHK%index%, ~                  ;Remove tilde (~) and Win (#) modifiers...
 StringReplace, noMods, noMods, #,,UseErrorLevel              ;They are incompatible with hotkey controls (cannot be shown).
 Gui, Add, Hotkey, x+5 w50 vHK%index% gGuiLabel, %noMods%        ;Add hotkey controls and show saved hotkeys.
 if(!checked)
  Gui, Add, CheckBox, x+5 vCB%index% gGuiLabel, Prevent Default Behavior  ;Add checkboxes to allow the Windows key (#) as a modifier..
 else
  Gui, Add, CheckBox, x+5 vCB%index% Checked gGuiLabel, Prevent Default Behavior  ;Add checkboxes to allow the Windows key (#) as a modifier..
}                                                               ;Check the box if Win modifier is used.

;----------Start Hotkey Handling-----------

; Create an object from vJoy Interface Class.
vJoyInterface := new CvJoyInterface()

; Was vJoy installed and the DLL Loaded?
if (!vJoyInterface.vJoyEnabled()) {
  ; Show log of what happened
  Msgbox % vJoyInterface.LoadLibraryLog
  ExitApp
}

myStick := vJoyInterface.Devices[1]


; Alert User that script has started
TrayTip, B0XX, modded Script Started, 3, 0


; state variables
buttonUp := false
buttonDown := false
buttonLeft := false
buttonRight := false

buttonA := false
buttonB := false
buttonL := false
buttonR := false
buttonX := false
buttonY := false
buttonZ := false

buttonLightShield := false
buttonMidShield := false

buttonModX := false
buttonModY := false

buttonCUp := false
buttonCDown := false
buttonCLeft := false
buttonCRight := false

mostRecentVertical := ""  ; this pair will go unused because of neutral SOCD
mostRecentHorizontal := ""

mostRecentVerticalC := ""  ; this pair will go unused because of neutral SOCD
mostRecentHorizontalC := ""

simultaneousHorizontalModifierLockout := false  ; will go unused in the new code because of neutral SOCD

currentTimeMS := 0
nerfLiftFire := false ; if a nerf lift timer fires this will be set true
upY := false ; if current Y is above deadzone 
upYTimestamp := -1000
downY := false
downYTimestamp := -1000
pivotForce2FJumpTimestamp := -1000   ; CarVac HayBox timed nerf. Inactive by default.
pivotForced2FJump := false                ; <--- Search references for this
uncrouchForced2FJump := false               ; <-- and this if you want to activate it
uncrouchForce2FJumpTimestamp := -1000

finalCoords := [0, 0] ; left stick coordinates that are intended to be sent to vjoy

; coordinate components simple array keys
xComp := 1, yComp := 2

; these variables are to be used as value identifiers. not keys
DIDNT_SCAN := -1
P_NONE := 0, P_RIGHTLEFT := 1, P_LEFTRIGHT := 2 ; id: no pivot, right to left pivot, or left to right pivot 
U_NOT := 0 , U_YES := 1 ; id: no uncrouch or yes uncrouched from detector
NOT_DASH := 0 ; id: when the x coordinate is in neither of the zones that trigger dash
ZONE_CENTER := 0 ; id: when the x and y coordinate is in no zone that can trigger SDI
; for bitwise calculations:
ZONE_DIR := ((1<<4) - 1)  ; 0b0000'1111
ZONE_U := 1               ; 0b0000'0001
ZONE_D := 1<<1            ; 0b0000'0010
ZONE_L := 1<<2
ZONE_R := 1<<3
BITS_SDI := ((1<<4) - 1) << 4 ; 0b1111'0000
BITS_SDI_QUARTERC := 1<<4     ; 0b0001'0000
BITS_SDI_TAP_CARD := 1<<5     ; 0b0010'0000
BITS_SDI_TAP_DIAG := 1<<6
BITS_SDI_TAP_CRDG := 1<<7
; mapping sdi zone bit population count, to direction type
POP_CENTER := 0, POP_CARD := 1, POP_DIAG := 2
; analog history simultaneousFinish bits
FINAL_DASHZONE := 1, FINAL_SDIZONE := 1<<1, FINAL_CROUCHRANGE := 1<<2

; analog history
analogHistory := []
Loop, % ANALOG_HISTORY_LENGTH {
  analogHistory[A_Index] := {x : 0, y : 0, timestamp : -1000, simultaneousFinish : 0}
}
currentIndexA := 1 ; the index for accessing analog history


; // for sdi nerfs, we want to record only movement between sdi zones, ignoring movement within zones
sdiZoneHist := []
Loop, % SDI_HISTORY_LENGTH {
  sdiZoneHist[A_Index] := {timestamp : -1000, stale : true, zone : ZONE_CENTER, popcount : 0}
}
sdiSimultZone := ZONE_CENTER
sdiSimultTimestamp := -1000

; // for pivot nerfs, we want to record only movement between dash zones, ignoring movement within zones
dashZoneHist := []
Loop, % DASH_HISTORY_LENGTH {
  dashZoneHist[A_Index] := {timestamp : -1000, stale : true, zone : NOT_DASH}
}
dashZone := {unsaved : NOT_DASH}
dashZoneTimestamp := {unsaved : -1000, simultaneous : -1000}
pivotDirection := {fromDetector : P_NONE, unsaved : P_NONE, saved : P_NONE} ; pivot values : P_NONE , P_RIGHTLEFT , P_LEFTRIGHT
pivotTimestamp := {fromDetector : -1000, unsaved : -1000, saved : -1000}
pivotWasNerfed := false

crouchRange := {unsaved : false, saved : false}
crouchRangeTimestamp := {simultaneous : -1000}
uncrouchTimestamp := {fromDetector : -1000, unsaved : -1000, saved : -1000}
uncrouched := {fromDetector : false, unsaved : false, saved : false}
uncrouchWasNerfed := false

; b0xx constants. ; coordinates get mirrored and rotated appropiately thanks to reflectCoords()
; MOVED TO targetCoordinateAssignations


 /* the banned coordinate list should be near here if we are going to put it in the script 
 */


/* Manual_Nerf_Testing
  0 no test mode
  1 pivoting, to u-tilt or d-tilt range in less than 8 frames
  2 pivoting, to up-angled f-tilt in less than 8 frames
  3 pivoting, to down-angled f-tilt in less than 8 frames
  4 dashing above or below deadzone (to time out the tap-jump or d-smash execution window by placing the stick in the same active y zone)
    then pivoting and inputting an up-tilt or d-tilt under 5 frames
  5 Crouching to u-tilt range in less than 3 frames

  follow execution instructions below
*/
Switch nerfTestMode
{
  case 1:  ; pivot by left/right NSOCD while pressing up or down (optional: then press A)
      target.normal.vertical := [0, ANALOG_DEAD_MAX + 2 * ANALOG_STEP]
      target.normal.quadrant := [79, 1]
  case 2:  ; pivot by modX while pressing up (optional: then press A)
      target.normal.quadrant := [79, 1]
      target.normal.vertical := target.normal.origin
  case 3:  ; pivot by modX while pressing down (optional: then press A)
      target.normal.quadrant := [79, 1]
      target.normal.vertical := target.normal.origin
      target.normal.quadrantModX := [ANALOG_DEAD_MAX + 7 * ANALOG_STEP, ANALOG_DEAD_MAX + ANALOG_STEP]
  case 4:  ; pivot by left/right NSOCD while holding one of the vertical keys (optional: then press A)
      target.normal.quadrant := [72 + ANALOG_STEP, ANALOG_DEAD_MAX + 2 * ANALOG_STEP]
      target.normal.vertical := [0, ANALOG_DEAD_MAX + 2 * ANALOG_STEP]
  case 5:  ; crouch by holding down and tapping modY and then attempt to uptilt using up with no modX
      target.normal.vertical := [0, -ANALOG_CROUCH]
}


; Debug info
/*
  In the agirardeaudale code, lastCoordTrace was used as an intended inputs display
  as opposed to a final, real outputs display. These two did differ in the turnaround side B case. 
  
  from what i gathered, this is how you read its values:
  L-Q-X means
  airdodge quadrant modX input
  F-Y-U means
  fireFox/extended modY c-up input

  L airdodge   H horizontal   X modX  U c-up
  N no shield  Q quadrant     Y modY  L c-left
               Y vertical             D c-down
               F fireFox/ext          R c-right
               O [0, 0]
*/
lastCoordTrace := ""


reverseNeutralBNerf(aX, aY) {
  global

  result := [aX, aY]

  if (buttonB and Abs(aX) > ANALOG_DEAD_MAX and Abs(aY) <= ANALOG_DEAD_MAX) { ; out of x deadzone and in y deadzone
    if (aX < 0 and aX > ANALOG_SPECIAL_LEFT) { ; inside leftward neutral-B range
      result[xComp] := ANALOG_STICK_MIN
      result[yComp] := 0
    } else if (aX > 0 and aX < ANALOG_SPECIAL_RIGHT) {
      result[xComp] := ANALOG_STICK_MAX
      result[yComp] := 0
    } 
  }

  return result
}


yDeadzoneTrackAndFlag(aX, aY) {
  global
  
  if (aY > ANALOG_DEAD_MAX) {
    if (analogHistory[currentIndexA].y <= ANALOG_DEAD_MAX) { ; if the entry before current does not go above y deadzone
      upY := true
      upYTimestamp := currentTimeMS
    } 
  } else {
    upY := false
  }

  if (aY < ANALOG_DEAD_MIN) {
    if (analogHistory[currentIndexA].y >= ANALOG_DEAD_MIN) {
      downY := true
      downYTimestamp := currentTimeMS
    }
  } else {
    downY := false
  }

  return
}


dashZoneOf(aX) { ; 
  global ANALOG_DASH_LEFT
  global ANALOG_DASH_RIGHT
  global NOT_DASH
  global ZONE_L
  global ZONE_R
  if (aX <= ANALOG_DASH_LEFT) {
    result := ZONE_L
  } else if (aX >= ANALOG_DASH_RIGHT) {
    result := ZONE_R
  } else {
    result := NOT_DASH
  }
  return result
}



detectPivot(aX) {
  global

  result := P_NONE
  pivotDebug := false ; if you want to enable detectPivot() testing, set this true
  pivotDiscarded := -1 ; for testing
  detectorDashZone := dashZoneOf(aX)
  /* ; ignoring timing, has the player inputted the correct sequence?
    pivot inputs:
    --- past --- current
    3---2---1---aX        means:      notes:
        R   L   N       p rightleft
    R   -   L   N       p rightleft   (it's R N L N because there can't be R R or L L)
        L   R   N       p leftright
    L   -   R   N       p leftright   (L N R N)
  */

  if (detectorDashZone == NOT_DASH) {  
    if (dashZoneHist[1].zone == ZONE_L and (dashZoneHist[2].zone == ZONE_R or dashZoneHist[3].zone == ZONE_R)) {
      result := P_RIGHTLEFT
      pivotDiscarded := false
    }
    else if (dashZoneHist[1].zone == ZONE_R and (dashZoneHist[2].zone == ZONE_L or dashZoneHist[3].zone == ZONE_L)) {
      result := P_LEFTRIGHT
      pivotDiscarded := false
    }
  }

  /*
  debugMessage := detectorDashZone . "-"
  Loop, % DASH_HISTORY_LENGTH {
    debugMessage .= dashZoneHist[A_Index].zone . "-"
  }
  Msgbox % debugMessage
  */ 

  if (result != P_NONE) {  ; this is the code block for discarding pivot attempts

    pivotLength := currentTimeMS - dashZoneHist[1].timestamp ; ms, stores latest dash duration

    ; //check for staleness (meaning that some inputs are too old for this to be a successful pivot)
    if dashZoneHist[2].stale {
      result := P_NONE
      if !pivotDiscarded {
        pivotDiscarded := 1
      }
    } else if (dashZoneHist[2].zone == NOT_DASH and dashZoneHist[3].stale) { ; aX neutral  1 opposite  2 neutral  3 cardinal
      result := P_NONE
      if !pivotDiscarded {
        pivotDiscarded := 1
      }

    ; has the player only held the latest dash for around 1 frame in duration? that's necessary for pivoting
    } else if (pivotLength < TIMELIMIT_HALFFRAME or pivotLength > TIMELIMIT_FRAME + TIMELIMIT_HALFFRAME) {
      ; //less than 50% chance it was a successful pivot
      result := P_NONE
      if !pivotDiscarded {
        pivotDiscarded := 2
      }    
    }
  } ; end of block for discarding pivot attempts

  if pivotDebug {
    Switch pivotDiscarded {
      Case false:
          if (result == P_LEFTRIGHT) {
            Msgbox P_LEFTRIGHT
          } else if (result == P_RIGHTLEFT) {
            Msgbox P_RIGHTLEFT
          }
      Case 1:
          Msgbox stage 1 stale p_none
      Case 2:
          Msgbox stage 2 length p_none
    }
  }

  return result
}


pivotNerf(aX, aY, pivotDirectionIn, pivotTimestampIn) { 
  global

  preliminary := [aX, aY]

  pivotWasNerfed := true ; true when pivotNerf() runs
  doTrimCoordinate := true
  if (aX != 0 or aY != 0) {
    unityDistanceFactor := 1.1 * (ANALOG_STICK_MAX) / sqrt(aX**2 + aY**2)
    /* 
        if upY and the player has not shut off tap jump with actions done before completing the pivot (such as angled dash)
        and tap jump hasn't been forced already for this pivot
          force tap jump
        if downY and tap-down can be done
          carry to rim
        if the player has shut off tap jump with actions done before completing the pivot
        and tap jump hasn't been forced already for this pivot
          force f-tilt
        if the player has shut off tap down with actions done before completing the pivot
          force f-tilt
    */
  
    ; if upY and the player has not shut off tap jump WITH actions done before completing the pivot (such as upY dashes)
    if (upY and (currentTimeMS - upYTimestamp < TIMELIMIT_TAPSHUTOFF or upYTimestamp >= pivotTimestampIn) 
      and not pivotForced2FJump) { 
      pivotForced2FJump := false ; change to true to activate CarVac HayBox style timed nerf 
      pivotForce2FJumpTimestamp := currentTimeMS
  
      if (Abs(aX) > aY) {   ; //Force all upward angles to a minimum of 45deg away from the horizontal
                            ; //to prevent pivot uftilt and ensure tap jump
        if (aX > 0) {
          preliminary[xComp] := 90 ; = 127 cos 45deg
        } else if (aX < 0) {
          preliminary[xComp] := -90
        }
        preliminary[yComp] := 90 ; 127 sin 45deg
  
      } else {
        preliminary[xComp] := aX * unityDistanceFactor
        preliminary[yComp] := aY * unityDistanceFactor
      }
  
    ; if the player hasn't shut off tap downsmash
    } else if (downY and currentTimeMS - downYTimestamp < TIMELIMIT_TAPSHUTOFF) { 
  
      preliminary[xComp] := aX * unityDistanceFactor
      preliminary[yComp] := aY * unityDistanceFactor
  
    ; if the player shut off the tap-jump or tap upsmash, by pivoting with upY dashes
    } else if (upY and upYTimestamp < pivotTimestampIn
      and currentTimeMS - pivotTimestampIn < TIMELIMIT_PIVOTTILT_YDASH and not pivotForced2FJump) {
                
      if (pivotDirectionIn == P_RIGHTLEFT) {
        preliminary[xComp] := - FORCE_FTILT           ; apparently CarVac uses the opposite x directions for the ftilt.
      } else if (pivotDirectionIn == P_LEFTRIGHT) {   ; what does the proposal team mean when saying pressing A too early?
        preliminary[xComp] := FORCE_FTILT
      }
      preliminary[yComp] := FORCE_FTILT
      doTrimCoordinate := false
  
    ; if the player shut off tap downsmash, by pivoting with downY dashes
    } else if (downY and downYTimestamp < pivotTimestampIn 
    and currentTimeMS - pivotTimestampIn < TIMELIMIT_PIVOTTILT_YDASH) {
      if (pivotDirectionIn == P_RIGHTLEFT) {
        preliminary[xComp] := - FORCE_FTILT  
      } else if (pivotDirectionIn == P_LEFTRIGHT) {
        preliminary[xComp] := FORCE_FTILT
      }
      preliminary[yComp] := - FORCE_FTILT
      doTrimCoordinate := false
    } else {
      doTrimCoordinate := false
    }
  }

  if doTrimCoordinate {
    result := trimToCircle(preliminary[xComp], preliminary[yComp]) 
    return result
  } else {
    return preliminary
  }
  
}





countPopulation(bitsIn) { ; //not a general purpose popcount, this is specifically for sdi zones
  result := 0
  Loop,4 {
    result += (bitsIn>>(A_Index-1)) & 1
  }
  return result
}


sdiZone(aX, aY) { 
  global        

  result := 0
  if (Min(Abs(aX), Abs(aY)) <= ANALOG_DEAD_MAX) { ; is x or y in the deadzone
    if (aX >= ANALOG_SDI_RIGHT) {
      result |= ZONE_R
    } else if (aX <= ANALOG_SDI_LEFT) {
      result |= ZONE_L
    } else if (aY >= ANALOG_SDI_UP) {
      result |= ZONE_U
    } else if (aY <= ANALOG_SDI_DOWN) {
      result |= ZONE_D
    }
  } else if (aX**2 + aY**2 >= MELEE_SDI_RAD) { ; is the distance far enough for diagonal sdi
    if (aX > 0) {
      result |= ZONE_R
    } else { ; if aX < 0
      result |= ZONE_L
    }
    if (aY > 0) {
        result |= ZONE_U
    } else { ; if aY < 0
        result |= ZONE_D
    }
  }

  return result
}


isBurstSDI1Button(outputIn) {
  global

  output := outputIn

  ; //detect repeated center-cardinal sequences, or repeated cardinal-diagonal sequences
  ; // if we're changing zones back and forth
  if (sdiZoneHist[1].zone != sdiZoneHist[2].zone
    and sdiZoneHist[1].zone == sdiZoneHist[3].zone
    and sdiZoneHist[2].zone == sdiZoneHist[4].zone) {
    ;//check the time duration
    timePressToPress := sdiZoneHist[1].timestamp - sdiZoneHist[3].timestamp
    ;//We want to nerf it if there is more than one press every TIMELIMIT_BURSTSDI ms, 
    ;//but not if the previous release duration is less than 1 frame
    if (sdiZoneHist[4].stale == false and timePressToPress < TIMELIMIT_BURSTSDI and timePressToPress > TIMELIMIT_DEBOUNCE) {
      if (sdiZoneHist[1].zone == ZONE_CENTER or sdiZoneHist[2].zone == ZONE_CENTER) {
        output |= BITS_SDI_TAP_CARD ;//if one of the pairs of zones is zero, it's tapping a cardinal (or tapping a diagonal modifier)
      } else if (sdiZoneHist[1].popcount + sdiZoneHist[2].popcount == POP_DIAG + POP_CARD 
        and (sdiZoneHist[1].zone & sdiZoneHist[2].zone)) {
        output |= BITS_SDI_TAP_DIAG ;//one pair is cardinal and the other is adjacent diagonal
      }
    }
  }

  return output
}


isBurstSDICrDg(outputIn) {
  global
  output := outputIn

  ;//if the last 5 inputs are in the origin, one cardinal, and one diagonal
  ;//and that there was a recent return to center
  ;//at least one of each zone, and at least two diagonals
  origCount := 0
  cardCount := 0
  diagCount := 0
  diagZone := (1<<8) - 1 ; 0b1111'1111
  Loop,5 {
    popcnt := sdiZoneHist[A_Index].popcount
    if (popcnt == POP_CENTER) {
      origCount += 1
    } else if (popcnt == POP_CARD) {
      cardCount += 1
    } else { ; if popcnt == POP_DIAG
      diagCount += 1
      diagZone &= sdiZoneHist[A_Index].zone ;//if two of these diagonals don't match, it'll have zero or one bits set
                                                ; if they match, the pop will be two bits
    }
  }

  ;//to limit scope of these vars
  ;//check the bit count of diagonal matching
  diagMatch := countPopulation(diagZone) == 2
  ;//check whether the input was fast enough
  shortTime := (sdiZoneHist[1].timestamp - sdiZoneHist[5].timestamp < TIMELIMIT_BURSTSDI
    and sdiZoneHist[1].timestamp - sdiZoneHist[2].timestamp > TIMELIMIT_SIMULTANEOUS
    and sdiZoneHist[5].stale == false)
  ;// if only the same diagonal was pressed
  ;//              if the origin, cardinal, and two diagonals were all entered
  ;//                                                            within the time limit
  if(diagMatch and origCount and cardCount and diagCount > 1 and shortTime) {
    output |= BITS_SDI_TAP_CRDG
  }

  return output
}


isBurstSDIQuarterCircle(outputIn) {
  global
  output := outputIn

  ;//3 input sdi
  ;//center-cardinal-diagonal-diagonal
  ;//center-cardinal-diagonal-same cardinal-diagonal
  ;//all directions except center must be the same
  cardZone := (1<<8) - 1 ; 0b1111'1111
  diagZone := (1<<8) - 1
  origCount = 0;
  cardCount = 0;
  diagCount = 0;
  Loop,5 {
    popcnt := sdiZoneHist[A_Index].popcount
    if (popcnt == POP_CENTER) {
      origCount += 1
      break ;//stop counting once there's an origin
    } else if (popcnt == POP_CARD) {
      cardCount += 1
      cardZone &= sdiZoneHist[A_Index].zone ;//if there are two different cardinals then it'll have zero bits set
    } else { ; if popcnt == POP_DIAG
      diagCount += 1
      diagZone &= sdiZoneHist[A_Index].zone ; if these are adjacent, it'll have one bit set
    }
  }
  
  ;//to limit scope of these vars
  ;//check the bit count of diagonal matching
  adjacentDiag := countPopulation(diagZone) == 1 and (cardZone & diagZone)
  shortTime := sdiZoneHist[1].timestamp - sdiZoneHist[4].timestamp < TIMELIMIT_BURSTSDI
    and not (sdiZoneHist[3].stale or (sdiZoneHist[4].stale and sdiZoneHist[4].zone != ZONE_CENTER))
  ;//if it hit two different diagonals
  ;//                  hit origin, at least one cardinal, and two diagonals
  ;//                                                                within the time limit
  if (adjacentDiag and origCount and cardCount and diagCount > 1 and shortTime) {
    output |= BITS_SDI_QUARTERC
  }

  return output
}


detectBurstSDI(aX, aY) {
  global

  output := 0
  sdiZoneHist[1].zone := sdiZone(aX, aY)
  sdiZoneHist[1].popcount := countPopulation(sdiZoneHist[1].zone)
  sdiZoneHist[1].timestamp := currentTimeMS
  sdiZoneHist[1].stale := false

  output := isBurstSDI1Button(output)
  if (sdiZoneHist[1].zone != sdiZoneHist[2].zone) {
    output := isBurstSDICrDg(output)
  }
  output := isBurstSDIQuarterCircle(output)

  ;//return the last cardinal in the zone list before the last diagonal, useful for SDI diagonal nerfs.
  Loop, % SDI_HISTORY_LENGTH {
    if (sdiZoneHist[A_Index].popcount == POP_DIAG) {
      i := A_Index + 1
      while (i <= SDI_HISTORY_LENGTH) {
        if (sdiZoneHist[i].popcount == POP_CARD) {
          output |= sdiZoneHist[i].zone
          break
        }
        i += 1
      }
      break
    }
  }

  return output
}


getFuzzyHorizontal100(outputX, outputY, historyX, historyY) {   ; if you input +/- 80, that value may be passed to the game
                                                                ; as +/- 79 for as long as you hold the stick in the same place
  global ANALOG_STICK_MAX
  global ANALOG_STEP
  global FUZZ_1_00_PROBABILITY

  if(Abs(outputY) <= ANALOG_STEP and Abs(outputX) == ANALOG_STICK_MAX) {
    if (Abs(historyY) <= ANALOG_STEP and outputX == historyX) {
      return historyY
    } else {
      Random, ran100, 0, 99  ; spans 100%
      if (ran100 < FUZZ_1_00_PROBABILITY) {
        result := Mod(ran100, 2) ? ANALOG_STEP : (-ANALOG_STEP)
        return result
      } else {
        return 0
      }
    } 
  } else {
    return outputY
  }
}


updateDashZoneHistory() {
  global

  /* we need to see if enough time has passed for the input to not be part of a multiple key single input. and that it is different
  from the last entry and so we need a new entry
  */
  if (currentTimeMS - dashZoneTimestamp.simultaneous >= TIMELIMIT_SIMULTANEOUS
    and dashZoneHist[1].zone != dashZone.unsaved) {
    i := DASH_HISTORY_LENGTH - 1
    ; push everything 1 slot towards the back of the timeline
    while (i >= 1) { 
      dashZoneHist[i + 1].timestamp := dashZoneHist[i].timestamp
      dashZoneHist[i + 1].stale := dashZoneHist[i].stale
      dashZoneHist[i + 1].zone := dashZoneHist[i].zone
      i -= 1
    }

    dashZoneHist[1].timestamp := dashZoneTimestamp.unsaved
    dashZoneHist[1].stale := false
    dashZoneHist[1].zone := dashZone.unsaved    
  } 
  /* debug tool
  else if (currentTimeMS - dashZoneTimestamp.simultaneous < TIMELIMIT_SIMULTANEOUS
    and dashZoneHist[1].zone != dashZone.unsaved) {
    Msgbox simultaneous change in dash zones
  }
  */

  return
}

makeDashZoneStale() {
  global
  ; check if a dash entry (and subsequent ones) are stale, and flag them
  Loop, % DASH_HISTORY_LENGTH { 
    if ((currentTimeMS - dashZoneHist[A_Index].timestamp) > (TIMESTALE_PIVOT_INPUTSEQUENCE)) {
      staleIndex := A_Index ; found stale entry
      while (staleIndex <= DASH_HISTORY_LENGTH) {
        dashZoneHist[staleIndex].stale := true
        staleIndex += 1
      }
      break
    }
  }

  return
}

savePivotHistory() {
  global

  updateDashZoneHistory()
  makeDashZoneStale()

  ; if there's an unsaved direction and the window for simultaneous inputs expired...
  if (pivotDirection.unsaved != P_NONE and currentTimeMS - dashZoneTimestamp.simultaneous >= TIMELIMIT_SIMULTANEOUS) {
    pivotDirection.saved := pivotDirection.unsaved
    pivotTimestamp.saved := pivotTimestamp.unsaved
    ; .saved will deal with the nerf from now on - .unsaved set to P_NONE means that an unsaved pivot was already taken care of
    pivotDirection.unsaved := P_NONE  
  }

  return
}

rememberDashZonesNotSaved(aX) {
  global
  ; if the dashzone that will sent to the game is different from the previous, then we record
  if (dashZoneOf(aX) != dashZone.unsaved) {
    dashZone.unsaved := dashZoneOf(aX)
    dashZoneTimestamp.unsaved := currentTimeMS
    ; we need to see if the current input actually represents a fresh new dash zone (either from a lone input or 
    ; as the FIRST keystroke of a group of simultaneous keystrokes) in order to assign a timestamp to it
    if (currentTimeMS - dashZoneTimestamp.simultaneous >= TIMELIMIT_SIMULTANEOUS) {
      dashZoneTimestamp.simultaneous := currentTimeMS
      analogHistory[currentIndexA].simultaneousFinish |= FINAL_DASHZONE
    }
  }

  return
}

saveUncrouchHistory() {
  global

  /* we need to see if enough time has passed for the input to not be part of a multiple key single input. and that it is different
  from the last entry and so we need a new entry
  */
  if (currentTimeMS - crouchRangeTimestamp.simultaneous >= TIMELIMIT_SIMULTANEOUS) {
    if (crouchRange.unsaved != crouchRange.saved) { ; requiring this to be true is not useful but we focus on showing all the steps
      crouchRange.saved := crouchRange.unsaved
    }
    if uncrouched.unsaved {
      uncrouched.saved := uncrouched.unsaved
      uncrouchTimestamp.saved := uncrouchTimestamp.unsaved
      uncrouched.unsaved := false
    }
  }
  return
}

crouchRangeOf(aY) {
  global ANALOG_CROUCH
  if (aY <= ANALOG_CROUCH) {
    result := true
  } else {
    result := false
  }
  return result
}

detectUncrouch(aY) {
  global
  if (not crouchRangeOf(aY) and crouchRange.saved) {
    result := U_YES
  } else {
    result := U_NOT
  }
  return result
}

uncrouchNerf(aX, aY) {
  global
  result := [aX, aY]


    uncrouchWasNerfed := true
    if (upY and Abs(aX) <= ANALOG_DEAD_MAX) {
      result[xComp] := 0
      result[yComp] := ANALOG_STICK_MAX        
      uncrouchForced2FJump := false ; change to true to activate CarVac HayBox style timed nerf 
      uncrouchForce2FJumpTimestamp := currentTimeMS
    }
  

  return result
}

rememberCrouchesNotSaved(aY) {
  global
  if (crouchRangeOf(aY) != crouchRange.unsaved) {
    crouchRange.unsaved := crouchRangeOf(aY)
    if (currentTimeMS - crouchRangeTimestamp.simultaneous >= TIMELIMIT_SIMULTANEOUS) {
      crouchRangeTimestamp.simultaneous := currentTimeMS
      analogHistory[currentIndexA].simultaneousFinish |= FINAL_CROUCHRANGE
    }
  }
  return
}

updateSDIZoneHistory() {
  global

  ; we need to see if enough time has passed for the input to not be part of a multiple key single input

  ; sdiZoneHist update
  ; we reserve sdiZoneHist[1, zh] for sdi detector
  if (currentTimeMS - sdiSimultTimestamp >= TIMELIMIT_SIMULTANEOUS
    and sdiZoneHist[2].zone != sdiSimultZone) {
    i := SDI_HISTORY_LENGTH - 1
    while (i >= 2) {
      sdiZoneHist[i + 1].timestamp := sdiZoneHist[i].timestamp
      sdiZoneHist[i + 1].stale := sdiZoneHist[i].stale
      sdiZoneHist[i + 1].zone := sdiZoneHist[i].zone
      sdiZoneHist[i + 1].popcount := sdiZoneHist[i].popcount
      i -= 1
    }
    sdiZoneHist[2].timestamp := sdiSimultTimestamp
    sdiZoneHist[2].stale := false
    sdiZoneHist[2].zone := sdiSimultZone
    sdiZoneHist[2].popcount := countPopulation(sdiSimultZone)
  }

  return
}

makeSDIZoneStale() {
  global

  Loop, % SDI_HISTORY_LENGTH { ; check if a sdi zone entry (and subsequent ones) are stale, and flag them
    if (currentTimeMS - sdiZoneHist[A_Index].timestamp > TIMESTALE_SDI_INPUTSEQUENCE) {
      staleIndex := A_Index ; found stale entry
      while(staleIndex <= SDI_HISTORY_LENGTH) {
        sdiZoneHist[staleIndex].stale := true
        staleIndex += 1
      }
      break
    }
  }

  return
}

saveSDIHistory() {
  global

  updateSDIZoneHistory()
  makeSDIZoneStale()

  return
}

rememberSDIZonesNotSaved(aX, aY) {
  global

  /*

  if (currentTimeMS - sdiSimultTimestamp >= TIMELIMIT_SIMULTANEOUS and sdiZone(aX, aY) != sdiSimultZone) {
    sdiSimultZone := sdiZone(aX, aY)
    sdiSimultTimestamp := currentTimeMS
    analogHistory[currentIndexA].simultaneousFinish |= FINAL_SDIZONE
  }
  */
  
  return
}


updateAnalogHistory(aX, aY) {
  global

  ; currentIndexA is lagging 1 behind the current input. we need to see if the current input actually represents a new analog coordinate
  ; otherwise the history simply ignores the repeated input and the index doesn't move from what was once new
  if (analogHistory[currentIndexA].x != aX or analogHistory[currentIndexA].y != aY) {
    ; save current analog stick position info in history
    currentIndexA := (currentIndexA == ANALOG_HISTORY_LENGTH) ? 1 : (currentIndexA + 1)  ; this index goes in circles...
    analogHistory[currentIndexA].timestamp := currentTimeMS
    analogHistory[currentIndexA].x := aX
    analogHistory[currentIndexA].y := aY
    analogHistory[currentIndexA].simultaneousFinish := 0
  }

  return
}


limitOutputs(rawCoords) {
  global

  currentTimeMS := A_TickCount

  savePivotHistory()

  saveSDIHistory()

  saveUncrouchHistory()

  ; this will contain the coordinates that this function will return. they will include any necessary nerf
  limitedOutput := {}

  
  
  ; a jump that lasts for JUMP_TIME ms (2 frames) that is a way to nerf u-tilt attempts
  if ((currentTimeMS - pivotForce2FJumpTimestamp < JUMP_TIME and pivotForced2FJump and pivotDirection.unsaved == P_NONE)
      or (currentTimeMS - uncrouchForce2FJumpTimestamp < JUMP_TIME and uncrouchForced2FJump and !uncrouched.unsaved)) {
      limitedOutput.leftStickX := analogHistory[currentIndexA].x ; force output to keep the last coordinate (a jump)
      limitedOutput.leftStickY := analogHistory[currentIndexA].y

  } else { ; process the player input and converts it into legal output
      
      limitedOutput.leftStickX := rawCoords[xComp]
      limitedOutput.leftStickY := rawCoords[yComp]
      processed := reverseNeutralBNerf(limitedOutput.leftStickX, limitedOutput.leftStickY)
      limitedOutput.leftStickX := processed[xComp]
      limitedOutput.leftStickY := processed[yComp]

      ; updates upY, downY, upYTimestamp, downYTimestamp
      yDeadzoneTrackAndFlag(limitedOutput.leftStickX, limitedOutput.leftStickY)

      ; if the dash zone of the player input changes, we need to see if this marks a successful input of a pivot
      pivotDirection.fromDetector := DIDNT_SCAN
      pivotWasNerfed := false
      if (dashZoneOf(limitedOutput.leftStickX) != dashZone.unsaved) {
          pivotDirection.fromDetector := detectPivot(limitedOutput.leftStickX)
          if (pivotDirection.fromDetector != P_NONE) {
              pivotForced2FJump := false
              pivotTimestamp.fromDetector := currentTimeMS
              nerfedPivotCoords := pivotNerf(limitedOutput.leftStickX, limitedOutput.leftStickY
                  , pivotDirection.fromDetector, pivotTimestamp.fromDetector)
              ; if the player spoiled the successful pivot instantaneously after inputting it...
          } else if (currentTimeMS - dashZoneTimestamp.simultaneous < TIMELIMIT_SIMULTANEOUS
              and dashZoneTimestamp.simultaneous <= pivotTimestamp.fromDetector) {
              pivotForced2FJump := false
          }
      }
      ; if the instantaneous pivot detector didn't alert of a newfound pivot, we check to see if we need to nerf based on previous pivots
      if (!pivotWasNerfed) {
          ; if there's a pivot outputted previously and the player hasn't spoiled it with simultaneous inputs yet
          if (pivotDirection.unsaved != P_NONE and dashZoneOf(limitedOutput.leftStickX) == dashZone.unsaved) {
              nerfedPivotCoords := pivotNerf(limitedOutput.leftStickX, limitedOutput.leftStickY
                  , pivotDirection.unsaved, pivotTimestamp.unsaved)
              ; nerfing the output is considered until TIMELIMIT_PIVOTTILT milliseconds pass
          } else if (currentTimeMS - pivotTimestamp.saved < TIMELIMIT_PIVOTTILT) {
              nerfedPivotCoords := pivotNerf(limitedOutput.leftStickX, limitedOutput.leftStickY
                  , pivotDirection.saved, pivotTimestamp.saved)
          } else {
              pivotForced2FJump := false
          }
      }
      if pivotWasNerfed {
          limitedOutput.leftStickX := nerfedPivotCoords[xComp]
          limitedOutput.leftStickY := nerfedPivotCoords[yComp]
      }

      ; roundabout way to determine if we should nerf uncrouching...
      uncrouched.fromDetector := DIDNT_SCAN
      uncrouchWasNerfed := false
      if (crouchRangeOf(limitedOutput.leftStickY) != crouchRange.unsaved) {
          uncrouched.fromDetector := detectUncrouch(limitedOutput.leftStickY)
          if (uncrouched.fromDetector == U_YES) {
              uncrouchForced2FJump := false
              uncrouchTimestamp.fromDetector := currentTimeMS
              nerfedUncrouchCoords := uncrouchNerf(limitedOutput.leftStickX, limitedOutput.leftStickY)
          } else if (currentTimeMS - crouchRangeTimestamp.simultaneous < TIMELIMIT_SIMULTANEOUS
              and crouchRangeTimestamp.simultaneous <= uncrouchTimestamp.fromDetector) { ; and uncrouched.fromDetector == U_NOT
              uncrouchForced2FJump := false
          }
      }
      if (!uncrouchWasNerfed) {
          if (uncrouched.unsaved and crouchRangeOf(limitedOutput.leftStickY) == crouchRange.unsaved) {
              nerfedUncrouchCoords := uncrouchNerf(limitedOutput.leftStickX, limitedOutput.leftStickY)
          } else if (currentTimeMS - uncrouchTimestamp.saved < TIMELIMIT_DOWNUP) {
              nerfedUncrouchCoords := uncrouchNerf(limitedOutput.leftStickX, limitedOutput.leftStickY)
          } else { ; if !uncrouchWasNerfed
              uncrouchForced2FJump := false
          }
      }
      if uncrouchWasNerfed {
          limitedOutput.leftStickX := nerfedUncrouchCoords[xComp]
          limitedOutput.leftStickY := nerfedUncrouchCoords[yComp]
      }

      ; WIP
      ; sdi := detectBurstSDI(limitedOutput.leftStickX, limitedOutput.leftStickY)
      
      ; fuzz the y when x is +1.00 or -1.00
      limitedOutput.leftStickY := getFuzzyHorizontal100(limitedOutput.leftStickX, limitedOutput.leftStickY
          , analogHistory[currentIndexA].x, analogHistory[currentIndexA].y)
          
      ; if the detected pivot will be passed to the game, record it as "unsaved"
      ; handles the case of nerfing the "neutral" of a pivot into a dash, so it damages the successful pivot input
      if (pivotDirection.fromDetector == P_RIGHTLEFT or pivotDirection.fromDetector == P_LEFTRIGHT) {
          if (dashZoneOf(limitedOutput.leftStickX) == NOT_DASH) {
              pivotTimestamp.unsaved := pivotTimestamp.fromDetector
              pivotDirection.unsaved := pivotDirection.fromDetector
          } else if (dashZoneOf(limitedOutput.leftStickX) != NOT_DASH) {
              pivotDirection.unsaved := P_NONE
          }
      } else if (pivotDirection.fromDetector == P_NONE){
          pivotDirection.unsaved := P_NONE
      }

      ; if the detected uncrouch will be passed to the game, record it as "unsaved"
      ; handles the case of nerfing the uncrouch input into a crouch, so it damages the successful uncrouch input
      if (uncrouched.fromDetector == U_YES) {
          if (not crouchRangeOf(limitedOutput.leftStickY)) {
              uncrouchTimestamp.unsaved := uncrouchTimestamp.fromDetector
              uncrouched.unsaved := true
          } else { ; if crouchRangeOf(limitedOutput.leftStickY)
              uncrouched.unsaved := false
          }
      } else if (uncrouched.fromDetector == U_NOT) {
          uncrouched.unsaved := false
      }

  } ; end of processing the player input and converting it into legal output

  rememberSDIZonesNotSaved(limitedOutput.leftStickX, limitedOutput.leftStickY)

  rememberDashZonesNotSaved(limitedOutput.leftStickX)

  rememberCrouchesNotSaved(limitedOutput.leftStickY)
  ; memorizes realtime leftstick coordinates passed to the game
  updateAnalogHistory(limitedOutput.leftStickX, limitedOutput.leftStickY)

  

  return limitedOutput
}



; Utility functions

up() {
  global
  return buttonUp and not buttonDown ; here is the neutral SOCD implementation
}

down() {
  global
  return buttonDown and not buttonUp
}

left() {
  global
  return buttonLeft and not buttonRight
}

right() {
  global
  return buttonRight and not buttonLeft
}

cUp() {
  global
  return buttonCUp and not buttonCDown and not bothMods()
}

cDown() {
  global
  return buttonCDown and not buttonCUp and not bothMods()
}

cLeft() {
  global
  return buttonCLeft and not buttonCRight and not bothMods()
}

cRight() {
  global
  return buttonCRight and not buttonCLeft and not bothMods()
}

modX() {
  global
  ; deactivate if either:
  ;   - modY is also held
  ;   - both left and right are held (and were pressed after modX) while neither up or down is active (
  ; this last bullet point won't carry into the new code because of NSOCD
  return buttonModX and not buttonModY
}

modY() {
  global
  return buttonModY and not buttonModX
}

anyVert() {
  global
  return up() or down()
}

anyHoriz() {
  global
  return left() or right()
}

anyQuadrant() {
  global
  return anyVert() and anyHoriz()
}

anyMod() {
  global
  return modX() or modY()
}

bothMods() {
  global
  return buttonModX and buttonModY
}

anyShield() {
  global
  return buttonL or buttonR or buttonLightShield or buttonMidShield
}

anyVertC() {
  global
  return cUp() or cDown()
}

anyHorizC() {
  global
  return cLeft() or cRight()
}

anyC() {
  global
  return cUp() or cDown() or cLeft() or cRight()
}


; Updates the position on the analog stick based on the current held buttons
updateAnalogStick() {
  global finalCoords
  global INT_TO_UNITCIRC

  coords := getAnalogCoords()
  finalOutput := limitOutputs(coords)
  finalCoords := [finalOutput.leftStickX, finalOutput.leftStickY]
  setAnalogStick(finalCoords)
}



updateCStick() {
  setCStick(getCStickCoords())
}

getAnalogCoords() {
  global
  if (anyShield()) {
    coords := getAnalogCoordsAirdodge()
  } else if (anyMod() and anyQuadrant() and (anyC() or buttonB)) {
    coords := getAnalogCoordsFirefox()
  } else {
    coords := getAnalogCoordsWithNoShield()
  }

  return reflectCoords(coords)
}

reflectCoords(coords) {
  x := coords[1]
  y := coords[2]
  if (down()) {
    y := -y
  }
  if (left()) {
    x := -x
  }
  return [x, y]
}

getAnalogCoordsAirdodge() {
  global
  if (neither(anyVert(), anyHoriz())) {
    lastCoordTrace := "L-O"
    return new target.normal.origin
  } else if (anyQuadrant()) {
    if (modX()) {
      lastCoordTrace := "L-Q-X"
      return new target.airdodge.quadrantModX
    } else if (modY()) {
      lastCoordTrace := "L-Q-Y"
      return up() ? new target.airdodge.quadrant12ModY : new target.airdodge.quadrant34ModY
    } else {
      lastCoordTrace := "L-Q"
      return up() ? new target.airdodge.quadrant12 : new target.airdodge.quadrant34
    }
  } else if (anyVert()) {
	if (modX()) {
      lastCoordTrace := "L-V-X"
      return new target.airdodge.verticalModX
    } else if (modY()) {
      lastCoordTrace := "L-V-Y"
      return new target.airdodge.verticalModY
    } else {
      lastCoordTrace := "L-V"
      return new target.airdodge.vertical
    }
  } else { ; if (anyHoriz())
    if (modX()) {
      lastCoordTrace := "L-H-X"
      return new target.airdodge.horizontalModX
    } else if (modY()) {
      lastCoordTrace := "L-H-Y"
      return new target.airdodge.horizontalModY
    } else {
      lastCoordTrace := "L-H"
      return new target.airdodge.horizontal
    }
  }
}

getAnalogCoordsWithNoShield() {
  global
  if (neither(anyVert(), anyHoriz())) {
    lastCoordTrace := "N-O"
    return new target.normal.origin
  } else if (anyQuadrant()) {
    if (modX()) {
      lastCoordTrace := "N-Q-X"
      return new target.normal.quadrantModX
    } else if (modY()) {
      lastCoordTrace := "N-Q-Y"
      return new target.normal.quadrantModY
    } else {
      lastCoordTrace := "N-Q"
      return new target.normal.quadrant
    }
  } else if (anyVert()) {
    if (modX()) {
      lastCoordTrace := "N-V-X"
      return new target.normal.verticalModX
    } else if (modY()) {
      lastCoordTrace := "N-V-Y"
      return new target.normal.verticalModY
    } else {
      lastCoordTrace := "N-V"
      return new target.normal.vertical
    }
  } else { ; if (anyHoriz())
    if (modX()) {
      lastCoordTrace := "N-H-X"
      return new target.normal.horizontalModX
    } else if (modY()) {
      lastCoordTrace := "N-H-Y"
      return new target.normal.horizontalModY
    } else {
      lastCoordTrace := "N-H"
      return new target.normal.horizontal
    }
  }
}

getAnalogCoordsFirefox() {
  global
  if (modX()) {
    if (cUp()) {
      lastCoordTrace := "F-X-U"
      return buttonB ? new target.extendedB.modXCUp : new target.fireFox.modXCUp
    } else if (cDown()) {
      lastCoordTrace := "F-X-D"
      return buttonB ? new target.extendedB.modXCDown : new target.fireFox.modXCDown
    } else if (cLeft()) {
      lastCoordTrace := "F-X-L"
      return buttonB ? new target.extendedB.modXCLeft : new target.fireFox.modXCLeft
    } else if (cRight()) {
      lastCoordTrace := "F-X-R"
      return buttonB ? new target.extendedB.modXCRight : new target.fireFox.modXCRight
    } else {
      lastCoordTrace := "F-X"
      ; if buttonB
      return new target.extendedB.modX
    }
  } else if (modY()) {
    if (cUp()) {
      lastCoordTrace := "F-Y-U"
      return buttonB ? new target.extendedB.modYCUp : new target.fireFox.modYCUp
    } else if (cDown()) {
      lastCoordTrace := "F-Y-D"
      return buttonB ? new target.extendedB.modYCDown : new target.fireFox.modYCDown
    } else if (cLeft()) {
      lastCoordTrace := "F-Y-L"
      return buttonB ? new target.extendedB.modYCLeft : new target.fireFox.modYCLeft
    } else if (cRight()) {
      lastCoordTrace := "F-Y-R"
      return buttonB ? new target.extendedB.modYCRight : new target.fireFox.modYCRight
    } else {
      lastCoordTrace := "F-Y"
      ; if buttonB
      return new target.extendedB.modY
    }
  }
}

setAnalogStick(finalCoords) {
  global myStick
  
  convertedCoords := convertIntegerCoords(finalCoords)
  myStick.SetAxisByIndex(convertedCoords[1], 1)
  myStick.SetAxisByIndex(convertedCoords[2], 2)
}

getCStickCoords() {
  global
  if (neither(anyVertC(), anyHorizC())) {
    cCoords := [0, 0]
  } else if (anyVertC() and anyHorizC()) {
    cCoords := [0.525, 0.85]
  } else if (anyVertC()) {
      cCoords := [0, 1]
  } else {
    if (modX() and up()) {
      cCoords := [0.9, 0.5]
    } else if (modX() and down()) {
      cCoords := [0.9, -0.5]
    } else {
      cCoords := [1, 0]
    }
  }

  return reflectCStickCoords(cCoords)
}

reflectCStickCoords(xAndY) {
  x := xAndY[1]
  y := xAndY[2]
  if (cDown()) {
    y := -y
  }
  if (cLeft()) {
    x := -x
  }
  return [x, y]
}

setCStick(cCoords) {
  global myStick
  convertedCoords := convertCoords(cCoords)
  myStick.SetAxisByIndex(convertedCoords[1], 4)
  myStick.SetAxisByIndex(convertedCoords[2], 5)
}

; Converts coordinates from box integers (circle diameter -80 to 80) to vJoy values (full range 0 to 32767).
convertIntegerCoords(xAndY) {
  result := []
  result[1] :=  16384 + Round(128.63 * xAndY[1])
  result[2] := 16301 - Round(128.38 * xAndY[2])
  return result
}

; Converts coordinates from melee values (-1 to 1) to vJoy values (0 to 32767).
convertCoords(xAndY) {
  mx = 10271 ; Why this number? idk, I would have thought it should be 16384 * (80 / 128) = 10240, but this works
  my = -10271
  bx = 16448 ; 16384 + 64
  by = 16320 ; 16384 - 64
  return [ mx * xAndY[1] + bx
         , my * xAndY[2] + by ]
}

setAnalogR(value) {
  global
  ; vJoy/Dolphin does something strange with rounding analog shoulder presses. In general,
  ; it seems to want to round to odd values, so
  ;   16384 => 0.00000 (0)   <-- actual value used for 0
  ;   19532 => 0.35000 (49)  <-- actual value used for 49
  ;   22424 => 0.67875 (95)  <-- actual value used for 94
  ;   22384 => 0.67875 (95)
  ;   22383 => 0.66429 (93)
  ; But, *extremely* inconsistently, I have seen the following:
  ;   22464 => 0.67143 (94)
  ; Which no sense and I can't reproduce. 
  convertedValue := 16384 * (1 + (value  / 255))
  myStick.SetAxisByIndex(convertedValue, 3)
}

neither(a, b) {
  return (not a) and (not b)
}

validateHK(GuiControl) {
 global lastHK
 Gui, Submit, NoHide
 lastHK := %GuiControl%                     ;Backup the hotkey, in case it needs to be reshown.
 num := SubStr(GuiControl,3)                ;Get the index number of the hotkey control.
 If (HK%num% != "") {                       ;If the hotkey is not blank...
  StringReplace, HK%num%, HK%num%, SC15D, AppsKey      ;Use friendlier names,
  StringReplace, HK%num%, HK%num%, SC154, PrintScreen  ;  instead of these scan codes.
  ;If CB%num%                                ;  If the 'Win' box is checked, then add its modifier (#).
   ;HK%num% := "#" HK%num%
  If (!CB%num% && !RegExMatch(HK%num%,"[#!\^\+]"))       ;  If the new hotkey has no modifiers, add the (~) modifier.
   HK%num% := "~" HK%num%                   ;    This prevents any key from being blocked.
  checkDuplicateHK(num)
 }
 If (savedHK%num% || HK%num%)               ;Unless both are empty,
  setHK(num, savedHK%num%, HK%num%)         ;  update INI/GUI
}

checkDuplicateHK(num) {
 global
 Loop,% hotkeys.Length()
  If (HK%num% = savedHK%A_Index%) {
   dup := A_Index
   TrayTip, B0XX, Hotkey Already Taken, 3, 0
   Loop,6 {
    GuiControl,% "Disable" b:=!b, HK%dup%   ;Flash the original hotkey to alert the user.
    Sleep,200
   }
   GuiControl,,HK%num%,% HK%num% :=""       ;Delete the hotkey and clear the control.
   break
  }
}

setHK(num,INI,GUI) {
 If INI{                          ;If previous hotkey exists,
  Hotkey, %INI%, Label%num%, Off  ;  disable it.
  Hotkey, %INI% UP, Label%num%_UP, Off  ;  disable it.
}
 If GUI{                           ;If new hotkey exists,
  Hotkey, %GUI%, Label%num%, On   ;  enable it.
  Hotkey, %GUI% UP, Label%num%_UP, On   ;  enable it.
}
 IniWrite,% GUI ? GUI:null, hotkeys.ini, Hotkeys, %num%
 savedHK%num%  := HK%num%
 ;TrayTip, Label%num%,% !INI ? GUI " ON":!GUI ? INI " OFF":GUI " ON`n" INI " OFF"
}

#MenuMaskKey vk07                 ;Requires AHK_L 38+
#If ctrl := HotkeyCtrlHasFocus()
 *AppsKey::                       ;Add support for these special keys,
 *BackSpace::                     ;  which the hotkey control does not normally allow.
 *Delete::
 *Enter::
 *Escape::
 *Pause::
 *PrintScreen::
 *Space::
 *Tab::
  modifier := ""
  If GetKeyState("Shift","P")
   modifier .= "+"
  If GetKeyState("Ctrl","P")
   modifier .= "^"
  If GetKeyState("Alt","P")
   modifier .= "!"
  Gui, Submit, NoHide             ;If BackSpace is the first key press, Gui has never been submitted.
  If (A_ThisHotkey == "*BackSpace" && %ctrl% && !modifier)   ;If the control has text but no modifiers held,
   GuiControl,,%ctrl%                                       ;  allow BackSpace to clear that text.
  Else                                                     ;Otherwise,
   GuiControl,,%ctrl%, % modifier SubStr(A_ThisHotkey,2)  ;  show the hotkey.
  validateHK(ctrl)
 return
#If

HotkeyCtrlHasFocus() {
 GuiControlGet, ctrl, Focus       ;ClassNN
 If InStr(ctrl,"hotkey") {
  GuiControlGet, ctrl, FocusV     ;Associated variable
  Return, ctrl
 }
}


;----------------------------Labels

;Show GUI from tray Icon
ShowGui:
    Gui, show,, Dynamic Hotkeys
    GuiControl, Focus, LB1 ; this puts the windows "focus" on the checkbox, that way it isn't immediately waiting for input on the 1st input box
return

GuiLabel:
 If %A_GuiControl% in +,^,!,+^,+!,^!,+^!    ;If the hotkey contains only modifiers, return to wait for a key.
  return
 If InStr(%A_GuiControl%,"vk07")            ;vk07 = MenuMaskKey (see below)
  GuiControl,,%A_GuiControl%, % lastHK      ;Reshow the hotkey, because MenuMaskKey clears it.
 Else
  validateHK(A_GuiControl)
return

;-------macros

Pause::Suspend
^!r:: Reload
SetKeyDelay, 0
#MaxHotkeysPerInterval 200

^!s::
  Suspend
    If A_IsSuspended
        TrayTip, B0XX, Hotkeys Disabled, 3, 0
    Else
        TrayTip, B0XX, Hotkeys Enabled, 3, 0
  Return


; Analog Up
Label1:
  buttonUp := true
  updateAnalogStick()
  updateCStick()
  return

Label1_UP:
  buttonUp := false
  updateAnalogStick()
  updateCStick()
  return

; Analog Down
Label2:
  buttonDown := true
  updateAnalogStick()
  updateCStick()
  return

Label2_UP:
  buttonDown := false
  updateAnalogStick()
  updateCStick()
  return

; Analog Left
Label3:
  buttonLeft := true
  updateAnalogStick()
  return

Label3_UP:
  buttonLeft := false
  updateAnalogStick()
  return

; Analog Right
Label4:
  buttonRight := true
  updateAnalogStick()
  return

Label4_UP:
  buttonRight := false
  updateAnalogStick()
  return

; ModX
Label5:
  buttonModX := true
  updateAnalogStick()
  updateCStick()
  return

Label5_UP:
  buttonModX := false
  updateAnalogStick()
  updateCStick()
  return

; ModY
Label6:
  buttonModY := true
  updateAnalogStick()
  return

Label6_UP:
  buttonModY := false
  updateAnalogStick()
  return

; A
Label7:
  buttonA := true
  myStick.SetBtn(1,5)
  return

Label7_UP:
  buttonA := false
  myStick.SetBtn(0,5)
  return

; B
Label8:
  buttonB := true
  myStick.SetBtn(1, 4)
  updateAnalogStick()
  return

Label8_UP:
  buttonB := false
  myStick.SetBtn(0, 4)
  updateAnalogStick()
  return

; L
Label9:
  buttonL := true
  myStick.SetBtn(1, 1)
  updateAnalogStick()
  return

Label9_UP:
  buttonL := false
  myStick.SetBtn(0, 1)
  updateAnalogStick()
  return

; R
Label10:
  buttonR := true
  myStick.SetBtn(1, 3)
  updateAnalogStick()
  return

Label10_UP:
  buttonR := false
  myStick.SetBtn(0, 3)
  updateAnalogStick()
  return

; X
Label11:
  buttonX := true
  myStick.SetBtn(1, 6)
  return

Label11_UP:
  buttonX := false
  myStick.SetBtn(0, 6)
  return

; Y
Label12:
  buttonY := true
  myStick.SetBtn(1, 2)
  return

Label12_UP:
  buttonY := false
  myStick.SetBtn(0, 2)
  return

; Z
Label13:
  buttonZ := true
  myStick.SetBtn(1, 7)
  updateAnalogStick()
  return

Label13_UP:
  buttonZ := false
  myStick.SetBtn(0, 7)
  updateAnalogStick()
  return

; C Up
Label14:
  buttonCUp := true
  if (bothMods()) {
    ; Pressing ModX and ModY simultaneously changes C buttons to D pad
    myStick.SetBtn(1, 9)
  } else {
    updateCStick()
    updateAnalogStick()
  }
  return

Label14_UP:
  buttonCUp := false
  myStick.SetBtn(0, 9)
  updateCStick()
  updateAnalogStick()
  return

; C Down
Label15:
  buttonCDown := true
  if (bothMods()) {
    ; Pressing ModX and ModY simultaneously changes C buttons to D pad
    myStick.SetBtn(1, 11)
  } else {
    updateCStick()
    updateAnalogStick()
  }
  return

Label15_UP:
  buttonCDown := false
  myStick.SetBtn(0, 11)
  updateCStick()
  updateAnalogStick()
  return

; C Left
Label16:
  buttonCLeft := true
  if (bothMods()) {
    ; Pressing ModX and ModY simultaneously changes C buttons to D pad
    myStick.SetBtn(1, 10)
  } else {
    updateCStick()
    updateAnalogStick()
  }
  return

Label16_UP:
  buttonCLeft := false
  myStick.SetBtn(0, 10)
  updateCStick()
  updateAnalogStick()
  return

; C Right
Label17:
  buttonCRight := true
  if (bothMods()) {
    ; Pressing ModX and ModY simultaneously changes C buttons to D pad
    myStick.SetBtn(1, 12)
  } else {
    updateCStick()
    updateAnalogStick()
  }
  return

Label17_UP:
  buttonCRight := false
  myStick.SetBtn(0, 12)
  updateCStick()
  updateAnalogStick()
  return

; Lightshield (Light)
Label18:
  buttonLightShield := true
  setAnalogR(49)
  return

Label18_UP:
  buttonLightShield := false
  setAnalogR(0)
  return

; Lightshield (Medium)
Label19:
  buttonMidShield := true
  setAnalogR(94)
  return

Label19_UP:
  buttonMidShield := false
  setAnalogR(0)
  return

; Start
Label20:
  myStick.SetBtn(1, 8)
  return

Label20_UP:
  myStick.SetBtn(0, 8)
  return

; D Up
Label21:
  myStick.SetBtn(1, 9)
  return

Label21_UP:
  myStick.SetBtn(0, 9)
  return

; D Down
Label22:
  myStick.SetBtn(1, 11)
  return

Label22_UP:
  myStick.SetBtn(0, 11)
  return

; D Left
Label23:
  myStick.SetBtn(1, 10)
  return

Label23_UP:
  myStick.SetBtn(0, 10)
  return

; D Right
Label24:
  myStick.SetBtn(1, 12)
  return

Label24_UP:
  myStick.SetBtn(0, 12)
  return

; Debug
Label25:
  debugString := getDebug()
  Msgbox % debugString 

Label25_UP:
  return


getDebug() {
  global
  activeArray := []
  pressedArray := []
  flagArray := []

  appendButtonState(activeArray, pressedArray, up(), buttonUp, "Up")
  appendButtonState(activeArray, pressedArray, down(), buttonDown, "Down")
  appendButtonState(activeArray, pressedArray, left(), buttonLeft, "Left")
  appendButtonState(activeArray, pressedArray, right(), buttonRight, "Right")

  appendButtonState(activeArray, pressedArray, modX(), buttonModX, "ModX")
  appendButtonState(activeArray, pressedArray, modY(), buttonModY, "ModY")

  appendButtonState(activeArray, pressedArray, buttonA, false, "A")
  appendButtonState(activeArray, pressedArray, buttonB, false, "B")
  appendButtonState(activeArray, pressedArray, buttonL, false, "L")
  appendButtonState(activeArray, pressedArray, buttonR, false, "R")
  appendButtonState(activeArray, pressedArray, buttonX, false, "X")
  appendButtonState(activeArray, pressedArray, buttonY, false, "Y")
  appendButtonState(activeArray, pressedArray, buttonZ, false, "Z")

  appendButtonState(activeArray, pressedArray, buttonLightShield, false, "LightShield")
  appendButtonState(activeArray, pressedArray, buttonMidShield, false, "MidShield")

  appendButtonState(activeArray, pressedArray, CUp(), buttonCUp, "C-Up")
  appendButtonState(activeArray, pressedArray, CDown(), buttonCDown, "C-Down")
  appendButtonState(activeArray, pressedArray, CLeft(), buttonCLeft, "C-Left")
  appendButtonState(activeArray, pressedArray, CRight(), buttonCRight, "C-Right")

  conditionalAppend(flagArray, simultaneousHorizontalModifierLockout, "SHML") ; unused in new code because of neutral SOCD

  activeButtonList := stringJoin(", ", activeArray)
  pressedButtonList := stringJoin(", ", pressedArray)
  flagList := stringJoin(", ", flagArray)

  trace1 := lastCoordTrace

  analogCoords := getAnalogCoords()
  cStickCoords := getCStickCoords()

  trace2 := lastCoordTrace

  trace := trace1 == trace2 ? trace1 : Format("{1}/{2}", trace1, trace2)

  debugFormatString = 
  (

    Analog Stick: [{1}, {2}]
    C Stick: [{3}, {4}]

    Active held buttons:
        {5}

    Disabled held buttons:
        {6}

    Flags:
        {7}

    Trace:
        {8}
  )

  return Format(debugFormatString
    , analogCoords[1], analogCoords[2]
    , cStickCoords[1], cStickCoords[2]
    , activeButtonList, pressedButtonList, flagList
    , trace)
}

appendButtonState(activeArray, pressedArray, isActive, isPressed, name) {
  if (isActive) {
    activeArray.Push(name)
  } else if (isPressed) {
    pressedArray.Push(name)
  }
}

conditionalAppend(array, condition, value) {
  if (condition) {
    array.Push(value)
  }
}

; From https://www.autohotkey.com/boards/viewtopic.php?t=7124
stringJoin(sep, params) {
    for index,param in params
        str .= param . sep
    return SubStr(str, 1, -StrLen(sep))
}


